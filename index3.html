<!DOCTYPE html>
<html>
<head></head>
<body>

<button id="create_node_element_list" onclick="create_node_element_list()">create_node_element_list</button>
     
<script src="https://unpkg.com/react/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom/umd/react-dom.development.js"></script>

<script>

// -------------------------------------------
     
var list_of_html_keys = [];
var list_of_html_values = [];

var desc_arr1_all = [];
var rowcol =  [];
var desc_arr1 = [];


// -------------------------------------------
// Step 0
// -------------------------------------------
async function create_node_element_list() {
     
     const htmlString = `<nav>
         <h1>Exploring navbar using React in JavaScript</h1>
           <ul><li>Item 0</li>
                 <li>Item 1</li>
                  <li>Item 2</li>
                 </ul></nav>`;
     
     const fragment = document.createRange().createContextualFragment(htmlString);
     console.log("fragment: ", fragment);

     // loop from the root down each tree
     let a = fragment;  // new version

     // new version
     await get_one_loop(a);
     
     console.log("list_of_html_keys: ", list_of_html_keys);
     console.log("list_of_html_values: ", list_of_html_values);
     console.log("total_keys_path2: ", total_keys_path2);

     // ------------------------------------

     let num_html = total_keys_path2.split(' ');
     console.log("num_html: ", num_html);
     
     // ------------------------------------

     // Remove empty fields
     // let num_html1 = num_html.map((x) => { if (x.length != 0) { return x } });
     // console.log("num_html1: ", num_html1);
     // note to self that the field is not removed  ["1", "nav", "2", "h1", "2", "ul", "3", "li", "3", "li", "3", "li", undefined]
     
     // let num_html2 = num_html.map((x) => { return x.length });
     // console.log("num_html2: ", num_html2);

     const NonEmptyVals_toKeep = (x) => x.length != 0;
     let num_html3 = num_html.filter(NonEmptyVals_toKeep);
     console.log("num_html3: ", num_html3);
     // OK ["1", "nav", "2", "h1", "2", "ul", "3", "li", "3", "li", "3", "li"]
     
     // ------------------------------------
     
     // assign desc_arr1_all
     let nested_str = await assign_desc_arr1_all(num_html3);
     console.log("nested_str: ", nested_str);
     // nested_str = [ "1 nav", "2 h1 2 ul", "3 li 3 li 3 li" ]
     
     // ------------------------------------

     // Use nested_str as a location template to assign strings
     let i = 0;
     let str_val = "";
     while (i < list_of_html_keys.length) {

          let regexp = new RegExp(`${list_of_html_keys[i]}`, 'g');

          console.log("list_of_html_keys[i]: ", list_of_html_keys[i]);

          nested_str.map((row, ind) => {
               if (regexp.test(row) == true) {
                    
                    console.log("row: ", row);
                    str_val = `level${ind}`;

                    // Determine if root or not and if the last nested_str value = list_of_html_keys[i]
                    let val = row.split(' ').pop();
                    console.log("val: ", val);
                    // console.log("regexp.test(val): ", regexp.test(val));
                    console.log("regexp result : ", row.split(' ').pop().replace(/[\s]/g, ''));
                    
                    if (ind < nested_str.length && (row.split(' ').pop().replace(/[\s]/g, '') == list_of_html_keys[i])) {
                         str_val += str_val + "_root";
                    }

                    // OR 
                    
                    // Determine if root or not
                    // if (ind < nested_str.length) {
                         // At least one of the html elements is a root
                         // does the last string equal the html element
                   //      let val = row.split(' ').pop();
                   //       console.log("val: ", val);
                    //      console.log("regexp.test(val): ", regexp.test(val));
                         
                   //       if (regexp.test(val) == true) {
                    //           str_val += str_val + "_root";
                   //       }
                   //  }
               }
          });
          console.log("str_val: ", str_val);
          desc_arr1_all.push(str_val);

          // Reset
          str_val = "";
          i += 1;
     }
     console.log("desc_arr1_all: ", desc_arr1_all);
  
     // ------------------------------------

     // assign rowcol and desc_arr1
     // let regex = '/root/g';
     // for (let i=0; i < list_of_html_values.length; i++) {

     //      if (regex.test(desc_arr1_all[i]) == true) {
               // a root is present
    //            list_of_html_values[i] = "";
    //            rowcol.push(list_of_html_keys[i]);
    //            desc_arr1.push(desc_arr1_all[i]);
    //       }
     // }

     // ------------------------------------
}


async function assign_desc_arr1_all(num_html) {
     
     // Created a nested 
     let accum_str = [];
     let nested_str = [];
     
     let i = 0;
     while (i < num_html.length) {
          accum_str.push(num_html.slice(i,i+2).join(' '));
          
          // Trigger when to store - if the next number value is not the same, store accumulated values
          if ((Number(num_html[i]) != Number(num_html[i+2])) || (i == num_html.length-2)) {
               nested_str.push(accum_str.join(' '));

               // Reset
               accum_str = [];
          }

          i = i + 2;
     }
     return nested_str;
}

     
// -------------------------------------------

var total_keys_path2 = "";
     
async function get_one_loop(a) {
     
     a = a.children;

     console.log("a.length: ", a.length);
     
     for (let i=0; i< a.length; i++) {
          console.log("i: ", i);
          
          console.log("a[i].localName: ", a[i].localName);
          list_of_html_keys.push(a[i].localName); // or tagName
          
          console.log("a[i].textContent: ", a[i].textContent);
          list_of_html_values.push(a[i].textContent);

          total_keys_path2 = total_keys_path2 + a.length + ' ' + a[i].localName + ' ';
               
          // go down into the object another level
          await get_one_loop(a[i]);
     }
}

// -------------------------------------------


     
</script>

</body>
</html>
